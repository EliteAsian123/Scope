func bool isPrime(long n) {
	if (n < 2l) {
		ret false;
	}
	
	for (long i = 2l, i * i <= n, i += 1l) {
		if (n % i == 0l) {
			ret false;
		}
	}
	
	ret true;
}

func bool isComposite(long n) {
	ret !isPrime(n);
}

func long[] factorsOf(long n) {
	long[] out = new long[0];
	
	// Temporary
	func void append(long arg) {
		long[] temp = out;
		out = new long[temp.length + 1];
		for (int i = 0, i < temp.length, i++) {
			out[i] = temp[i];
		}
		
		out[temp.length] = arg;
	}
	
	for (long i = 1l, i * i <= n, i += 1l) {
		if (n % i == 0l) {
			append(i);
		
			if (n / i != i) {
				append(n / i);
			}
		}
	}
	
	ret out;
}

func long factorial(long n) {
	if (n <= 1l) {
		ret 1l;
	}
	
	ret factorial(n - 1l) * n;
}

func float abs(float n) {
	if (n < 0f) {
		ret -n;
	}
	
	ret n;
}

func bool approximately(float a, float b, float error) {
	float diff = abs(a - b);
	ret diff <= error;
}

func float sqrt(float n) {
	if (n < 0f) {
		throw "Math Error: Cannot get the root of a negative number.";
	}
	
	ret extern(n, 3);
}